-- Test cases for the redefinition of variable with a different type (new version).

[case testRedefine2LocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
    x = ''
    reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2ConditionalLocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ''
        reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2MergeConditionalLocal1]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        x = 0
    else:
        x = ''
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def g() -> None:
    if int():
        x = 0
    else:
        x = None
    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"

[case testRedefine2GlobalVariableSimple]
# flags: --allow-redefinition2 --local-partial-types
if int():
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
else:
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"
reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f() -> None:
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2ClassBody]
# flags: --allow-redefinition2 --local-partial-types
class C:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

reveal_type(C.x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2OptionalTypesSimple]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = None
    if int():
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f2() -> None:
    if int():
        x = None
    elif int():
        x = ""
    else:
        x = 1
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str, builtins.int]"

def f3() -> None:
    if int():
        x = None
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f4() -> None:
    x = None
    reveal_type(x) # N: Revealed type is "None"

y = None
if int():
    y = 1
reveal_type(y) # N: Revealed type is "Union[None, builtins.int]"

if int():
    z = None
elif int():
    z = 1
else:
    z = ""
reveal_type(z) # N: Revealed type is "Union[None, builtins.int, builtins.str]"

[case testRedefine2OptionalTypeForInstanceVariabls]
# flags: --allow-redefinition2 --local-partial-types
class C:
    def __init__(self) -> None:
        self.x = None
        if int():
            self.x = 1
            reveal_type(self.x) # N: Revealed type is "builtins.int"
        reveal_type(self.x) # N: Revealed type is "Union[builtins.int, None]"

[case testRedefine2PartialGenericTypes]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f2() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    # Type context prevents type refinement
    a = [""] # E: List item 0 has incompatible type "str"; expected "int"
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f3() -> None:
    if int():
        a = []
        a.append(1)
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    else:
        b = [""]
        a = b
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
    reveal_type(a) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"

def f4() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    b = [""]
    a = b
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
[builtins fixtures/list.pyi]

[case testRedefine2FinalLiteral]
# flags: --allow-redefinition2 --local-partial-types
from typing_extensions import Final, Literal

x: Final = "foo"
reveal_type(x) # N: Revealed type is "Literal['foo']?"
a: Literal["foo"] = x
[builtins fixtures/tuple.pyi]
