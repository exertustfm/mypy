-- Test cases for the redefinition of variable with a different type (new version).

[case testRedefine2LocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
    x = ''
    reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2ConditionalLocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ''
        reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2MergeConditionalLocal1]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        x = 0
    else:
        x = ''
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def g() -> None:
    if int():
        x = 0
    else:
        x = None
    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"

[case testRedefine2GlobalVariableSimple]
# flags: --allow-redefinition2 --local-partial-types
if int():
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
else:
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"
reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f() -> None:
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2ClassBody]
# flags: --allow-redefinition2 --local-partial-types
class C:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

reveal_type(C.x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2OptionalTypesSimple]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = None
    if int():
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f2() -> None:
    if int():
        x = None
    elif int():
        x = ""
    else:
        x = 1
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str, builtins.int]"

def f3() -> None:
    if int():
        x = None
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f4() -> None:
    x = None
    reveal_type(x) # N: Revealed type is "None"

y = None
if int():
    y = 1
reveal_type(y) # N: Revealed type is "Union[None, builtins.int]"

if int():
    z = None
elif int():
    z = 1
else:
    z = ""
reveal_type(z) # N: Revealed type is "Union[None, builtins.int, builtins.str]"

[case testRedefine2OptionalTypeForInstanceVariabls]
# flags: --allow-redefinition2 --local-partial-types
class C:
    def __init__(self) -> None:
        self.x = None
        if int():
            self.x = 1
            reveal_type(self.x) # N: Revealed type is "builtins.int"
        reveal_type(self.x) # N: Revealed type is "Union[builtins.int, None]"

[case testRedefine2PartialGenericTypes]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f2() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    a = [""]
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"

def f3() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    a = []
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f4() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    # Partial types are currently not supported on reassignment
    a = []
    a.append("x") # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f5() -> None:
    if int():
        a = []
        a.append(1)
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    else:
        b = [""]
        a = b
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
    reveal_type(a) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"

def f6() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    b = [""]
    a = b
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
[builtins fixtures/list.pyi]

[case testRedefine2FinalLiteral]
# flags: --allow-redefinition2 --local-partial-types
from typing_extensions import Final, Literal

x: Final = "foo"
reveal_type(x) # N: Revealed type is "Literal['foo']?"
a: Literal["foo"] = x
[builtins fixtures/tuple.pyi]

[case testRedefine2AnnotatedVariable]
# flags: --allow-redefinition2 --local-partial-types
from typing import Optional

def f1() -> None:
    x: int = 0
    if int():
        x = "" # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(x) # N: Revealed type is "builtins.int"
    reveal_type(x) # N: Revealed type is "builtins.int"

def f2(x: Optional[str]) -> None:
    if x is not None:
        reveal_type(x) # N: Revealed type is "builtins.str"
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

class C:
    x: Optional[str]

    def f(self) -> None:
        if self.x is not None:
            reveal_type(self.x) # N: Revealed type is "builtins.str"
        else:
            self.x = ""
        reveal_type(self.x) # N: Revealed type is "builtins.str"

[case testRedefine2AnyType]
# flags: --allow-redefinition2 --local-partial-types
def a(): pass

def f1() -> None:
    if int():
        x = ""
    else:
        x = a()
        reveal_type(x) # N: Revealed type is "Any"
    reveal_type(x) # N: Revealed type is "Union[builtins.str, Any]"
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"

def f2() -> None:
    if int():
        x = a()
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[Any, builtins.str]"
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"

def f3() -> None:
    x = 1
    x = a()
    reveal_type(x) # N: Revealed type is "Any"
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

def f4() -> None:
    x = a()
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"
    x = a()
    reveal_type(x) # N: Revealed type is "Any"

def f5() -> None:
    x = a()
    if int():
        x = 1
        reveal_type(x) # N: Revealed type is "builtins.int"
    elif int():
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[Any, builtins.int, builtins.str]"

def f6() -> None:
    x = a()
    if int():
        x = 1
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

# TODO: declared type should take precedence
#def f7() -> None:
#    x: int
#   x = a()
#   reveal_type(x) # Revealed type is "builtins.int"
