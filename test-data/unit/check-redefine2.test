-- Test cases for the redefinition of variable with a different type (new version).

[case testRedefine2LocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
    x = ''
    reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2ConditionalLocalWithDifferentType]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ''
        reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2MergeConditionalLocal1]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    if int():
        x = 0
    else:
        x = ''
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f2() -> None:
    if int():
        x = 0
    else:
        x = None
    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"

def f3() -> None:
    if int():
        x = 0
        x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2GlobalVariableSimple]
# flags: --allow-redefinition2 --local-partial-types
if int():
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"
else:
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"
reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f1() -> None:
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f2() -> None:
    global x
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"

reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2ClassBody]
# flags: --allow-redefinition2 --local-partial-types
class C:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

reveal_type(C.x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2NestedFunctionBasics]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    if int():
        x = 0
    else:
        x = ""

    def nested() -> None:
        reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f2() -> None:
    if int():
        x = 0
    else:
        x = ""

    def nested() -> None:
        nonlocal x
        reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"

    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2LambdaBasics]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = 0
    if int():
        x = None
    f = lambda: reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"
    reveal_type(f) # N: Revealed type is "def () -> Union[builtins.int, None]"
    if x is None:
        x = ""
    f = lambda: reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
    reveal_type(f) # N: Revealed type is "def () -> Union[builtins.int, builtins.str]"

[case testRedefine2AssignmentExpression]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if x := int():
        reveal_type(x) # N: Revealed type is "builtins.int"
    elif x := str():
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2OperatorAssignment]
# flags: --allow-redefinition2 --local-partial-types
class D: pass
class C:
    def __add__(self, x: C) -> D: ...

c = C()
if int():
    c += C()
    reveal_type(c) # N: Revealed type is "__main__.D"
reveal_type(c) # N: Revealed type is "Union[__main__.C, __main__.D]"

[case testRedefine2ImportFrom]
# flags: --allow-redefinition2 --local-partial-types
if int():
    from m import x
else:
    # TODO: This could be useful to allow
    from m import y as x # E: Incompatible import of "x" (imported name has type "str", local name has type "int")
reveal_type(x) # N: Revealed type is "builtins.int"

if int():
    from m import y
else:
    y = 1
reveal_type(y) # N: Revealed type is "Union[builtins.str, builtins.int]"

[file m.py]
x = 1
y = ""

[case testRedefine2Import]
# flags: --allow-redefinition2 --local-partial-types
if int():
    import m
else:
    import m2 as m # E: Name "m" already defined (by an import)
m.x
m.y # E: Module has no attribute "y"

[file m.py]
x = 1

[file m2.py]
y = ""
[builtins fixtures/module.pyi]

[case testRedefine2OptionalTypesSimple]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = None
    if int():
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f2() -> None:
    if int():
        x = None
    elif int():
        x = ""
    else:
        x = 1
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str, builtins.int]"

def f3() -> None:
    if int():
        x = None
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f4() -> None:
    x = None
    reveal_type(x) # N: Revealed type is "None"

y = None
if int():
    y = 1
reveal_type(y) # N: Revealed type is "Union[None, builtins.int]"

if int():
    z = None
elif int():
    z = 1
else:
    z = ""
reveal_type(z) # N: Revealed type is "Union[None, builtins.int, builtins.str]"

[case testRedefine2OptionalTypeForInstanceVariabls]
# flags: --allow-redefinition2 --local-partial-types
class C:
    def __init__(self) -> None:
        self.x = None
        if int():
            self.x = 1
            reveal_type(self.x) # N: Revealed type is "builtins.int"
        reveal_type(self.x) # N: Revealed type is "Union[builtins.int, None]"

[case testRedefine2PartialGenericTypes]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f2() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    a = [""]
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"

def f3() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    a = []
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f4() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    # Partial types are currently not supported on reassignment
    a = []
    a.append("x") # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"

def f5() -> None:
    if int():
        a = []
        a.append(1)
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    else:
        b = [""]
        a = b
        reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
    reveal_type(a) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"

def f6() -> None:
    a = []
    a.append(1)
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.int]"
    b = [""]
    a = b
    reveal_type(a) # N: Revealed type is "builtins.list[builtins.str]"
[builtins fixtures/list.pyi]

[case testRedefine2FinalLiteral]
# flags: --allow-redefinition2 --local-partial-types
from typing_extensions import Final, Literal

x: Final = "foo"
reveal_type(x) # N: Revealed type is "Literal['foo']?"
a: Literal["foo"] = x
[builtins fixtures/tuple.pyi]

[case testRedefine2AnnotatedVariable]
# flags: --allow-redefinition2 --local-partial-types
from typing import Optional

def f1() -> None:
    x: int = 0
    if int():
        x = "" # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(x) # N: Revealed type is "builtins.int"
    reveal_type(x) # N: Revealed type is "builtins.int"

def f2(x: Optional[str]) -> None:
    if x is not None:
        reveal_type(x) # N: Revealed type is "builtins.str"
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

def f3() -> None:
    a: list[Optional[str]] = [""]
    reveal_type(a) # N: Revealed type is "builtins.list[Union[builtins.str, None]]"
    a = [""]
    reveal_type(a) # N: Revealed type is "builtins.list[Union[builtins.str, None]]"

class C:
    x: Optional[str]

    def f(self) -> None:
        if self.x is not None:
            reveal_type(self.x) # N: Revealed type is "builtins.str"
        else:
            self.x = ""
        reveal_type(self.x) # N: Revealed type is "builtins.str"

[case testRedefine2AnyType1]
# flags: --allow-redefinition2 --local-partial-types
def a(): pass

def f1() -> None:
    if int():
        x = ""
    else:
        x = a()
        reveal_type(x) # N: Revealed type is "Any"
    reveal_type(x) # N: Revealed type is "Union[builtins.str, Any]"
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"

def f2() -> None:
    if int():
        x = a()
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[Any, builtins.str]"
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"

def f3() -> None:
    x = 1
    x = a()
    reveal_type(x) # N: Revealed type is "Any"
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

def f4() -> None:
    x = a()
    x = 1
    reveal_type(x) # N: Revealed type is "builtins.int"
    x = a()
    reveal_type(x) # N: Revealed type is "Any"

def f5() -> None:
    x = a()
    if int():
        x = 1
        reveal_type(x) # N: Revealed type is "builtins.int"
    elif int():
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[Any, builtins.int, builtins.str]"

def f6() -> None:
    x = a()
    if int():
        x = 1
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f7() -> None:
    x: int
    x = a()
    reveal_type(x) # N: Revealed type is "builtins.int"

[case testRedefine2AnyType2]
# flags: --allow-redefinition2 --local-partial-types
from typing import Any

def f1() -> None:
    x: Any
    x = int()
    reveal_type(x) # N: Revealed type is "Any"

def f2() -> None:
    x: Any
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "Any"
    else:
        x = ""
        reveal_type(x) # N: Revealed type is "Any"
    reveal_type(x) # N: Revealed type is "Any"

def f3(x) -> None:
    if int():
        x = 0
        reveal_type(x) # N: Revealed type is "Any"
    reveal_type(x) # N: Revealed type is "Any"

[case tetRedefine2Del]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"
    del x
    reveal_type(x) # N: Revealed type is "<Deleted 'x'>"
    x = 0
    reveal_type(x) # N: Revealed type is "builtins.int"

def f2() -> None:
    if int():
        x = 0
        del x
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

def f3() -> None:
    if int():
        x = 0
    else:
        x = ""
        del x
    reveal_type(x) # N: Revealed type is "builtins.int"

[case testRedefine2WhileLoopSimple]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    while int():
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
        x = 0
        reveal_type(x) # N: Revealed type is "builtins.int"
    reveal_type(x) # N: Revealed type is "Union[builtins.str, builtins.int]"
    while int():
        x = None
        reveal_type(x) # N: Revealed type is "None"
        x = b""
        reveal_type(x) # N: Revealed type is "builtins.bytes"
    reveal_type(x) # N: Revealed type is "Union[builtins.str, builtins.int, None, builtins.bytes]"
    x = [1]
    reveal_type(x) # N: Revealed type is "builtins.list[builtins.int]"

[case testRedefine2WhileLoopOptional]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = None
    while int():
        if int():
            x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

def f2() -> None:
    x = None
    while int():
        reveal_type(x) # N: Revealed type is "None" \
                       # N: Revealed type is "Union[None, builtins.str]"
        if int():
            x = ""
    reveal_type(x) # N: Revealed type is "Union[None, builtins.str]"

[case testRedefine2WhileLoopPartialType]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x = []
    while int():
        x.append(1)
    reveal_type(x) # N: Revealed type is "builtins.list[builtins.int]"
[builtins fixtures/list.pyi]

[case testRedefine2Return]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    if int():
        x = 0
        return
    else:
        x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"

def f2() -> None:
    if int():
        x = ""
    else:
        x = 0
        return
    reveal_type(x) # N: Revealed type is "builtins.str"

[case testRedefine2BreakAndContinue]
# flags: --allow-redefinition2 --local-partial-types
def b() -> None:
    while int():
        x = ""
        if int():
            x = 1
            break
        reveal_type(x) # N: Revealed type is "builtins.str"
        x = None
    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"

def c() -> None:
    x = 0
    while int():
        reveal_type(x) # N: Revealed type is "builtins.int" \
                       # N: Revealed type is "Union[builtins.int, builtins.str, None]"
        if int():
            x = ""
            continue
        else:
            x = None
        reveal_type(x) # N: Revealed type is "None"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str, None]"

[case testRedefine2Underscore]
# flags: --allow-redefinition2 --local-partial-types
def f() -> None:
    if int():
        _ = 0
        reveal_type(_) # N: Revealed type is "builtins.int"
    else:
        _ = ""
        reveal_type(_) # N: Revealed type is "builtins.str"
    reveal_type(_) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2WithStatement]
# flags: --allow-redefinition2 --local-partial-types
class C:
    def __enter__(self) -> int: ...
    def __exit__(self, x, y, z): ...
class D:
    def __enter__(self) -> str: ...
    def __exit__(self, x, y, z): ...

def f1() -> None:
    with C() as x:
        reveal_type(x) # N: Revealed type is "builtins.int"
    with D() as x:
        reveal_type(x) # N: Revealed type is "builtins.str"

def f2() -> None:
    if int():
        with C() as x:
            reveal_type(x) # N: Revealed type is "builtins.int"
    else:
        with D() as x:
            reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

[case testRedefine2TryStatement]
# flags: --allow-redefinition2 --local-partial-types
class E(Exception): pass

def g(): ...

def f1() -> None:
    try:
        x = 1
        g()
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    except RuntimeError as e:
        reveal_type(e) # N: Revealed type is "builtins.RuntimeError"
        reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
    except E as e:
        reveal_type(e) # N: Revealed type is "__main__.E"
        reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
    reveal_type(e) # N: Revealed type is "<Deleted 'e'>"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"
[builtins fixtures/exception.pyi]

[case testRedefine2MultipleAssignment]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    x, y = 1, ""
    reveal_type(x) # N: Revealed type is "builtins.int"
    reveal_type(y) # N: Revealed type is "builtins.str"
    x, y = None, 2
    reveal_type(x) # N: Revealed type is "None"
    reveal_type(y) # N: Revealed type is "builtins.int"

def f2() -> None:
    if int():
        x, y = 1, ""
        reveal_type(x) # N: Revealed type is "builtins.int"
        reveal_type(y) # N: Revealed type is "builtins.str"
    else:
        x, y = None, 2
        reveal_type(x) # N: Revealed type is "None"
        reveal_type(y) # N: Revealed type is "builtins.int"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"
    reveal_type(y) # N: Revealed type is "Union[builtins.str, builtins.int]"

[case testRedefine2ForLoopBasics]
# flags: --allow-redefinition2 --local-partial-types
def f1() -> None:
    for x in [1]:
        reveal_type(x) # N: Revealed type is "builtins.int"
    for x in [""]:
        reveal_type(x) # N: Revealed type is "builtins.str"

def f2() -> None:
    if int():
        for x, y in [(1, "x")]:
            reveal_type(x) # N: Revealed type is "builtins.int"
            reveal_type(y) # N: Revealed type is "builtins.str"
    else:
        for x, y in [(None, 1)]:
            reveal_type(x) # N: Revealed type is "None"
            reveal_type(y) # N: Revealed type is "builtins.int"

    reveal_type(x) # N: Revealed type is "Union[builtins.int, None]"
    reveal_type(y) # N: Revealed type is "Union[builtins.str, builtins.int]"

def l() -> list[int]:
    return []

def f3() -> None:
    x = ""
    for x in l():
        reveal_type(x) # N: Revealed type is "builtins.int"
    reveal_type(x) # N: Revealed type is "Union[builtins.str, builtins.int]"
[builtins fixtures/for.pyi]

[case testRedefine2ForStatementIndexNarrowing]
# flags: --allow-redefinition2 --local-partial-types
from typing_extensions import TypedDict

class X(TypedDict):
    hourly: int
    daily: int

x: X
for a in ("hourly", "daily"):
    reveal_type(a)  # N: Revealed type is "Union[Literal['hourly']?, Literal['daily']?]"
    reveal_type(x[a])  # N: Revealed type is "builtins.int"
    reveal_type(a.upper())  # N: Revealed type is "builtins.str"
    c = a
    reveal_type(c)  # N: Revealed type is "builtins.str"

b: str
for b in ("hourly", "daily"):
    reveal_type(b)  # N: Revealed type is "builtins.str"
    reveal_type(b.upper())  # N: Revealed type is "builtins.str"
[builtins fixtures/for.pyi]

[case testRedefine2ForLoopIndexWidening]
# flags: --allow-redefinition2 --local-partial-types

def f1() -> None:
    for x in [1]:
        reveal_type(x) # N: Revealed type is "builtins.int"
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "builtins.str"

def f2() -> None:
    for x in [1]:
        reveal_type(x) # N: Revealed type is "builtins.int"
        if int():
            break
        x = ""
        reveal_type(x) # N: Revealed type is "builtins.str"
    reveal_type(x) # N: Revealed type is "Union[builtins.int, builtins.str]"

def f3() -> None:
    if int():
        for x in [1]:
            x = ""
    reveal_type(x) # N: Revealed type is "builtins.str"
